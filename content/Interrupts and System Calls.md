To execute a program, the components for a minimal set are:
- Main memory
- System Bus
- Processor
    - Within this, we have a I/O communicating data to us that requires some processing
    - Central Processing Unit (with a Control Unit and ALU) communicates with memory unit.

**Processor**

- Brain of the computer which fetches instructions, decodes them, executes them (a cycle which repeats infinitely)
- Different steps may be completed in parallel (pipeline) –> ECE 222
- The largest unit in a processor is the word:
    - 32-bit computer -> 32-bit word, 64-bit computer -> 64-bit word

**CPU**
- CPU instructions are specific to the processor (x86, ARM, RISC, MIFS)
    - Some instructions are only available in “supervisor” mode and running it in user mode is an error.
    - When running our programs, we can’t ask to “close” the computer or read input from keyboard directly. What if we do the wrong thing, crash the computer in a while loop forever?
- CPUs have storage locations called registers
    - These will store data or instructions. A great analogy is if memory is a bookshelf, these are your pockets - quick access to data
    - Management of registers is partially the role of the OS.

**Critical Registers in CPU**
- Program Counter - address of next instruction.
    - The reason we have this is because if statements or for loops, it’s not always sequential. We might need to branch back to a previous line.
- Status Register - Array of bits to indicate flags. For example, if we are in supervisor mode, if there’s low power
- Instruction Register - Instruction most recently fetched, so in decode stage, we can refer to this
- Stack Pointer - Where the local data is kept. We really care about this because all our local variables are here in memory
- General Purpose Registers - store data, addresses etc. Basically, pockets to put in data to use later.

How do we inform the computer of something that just happened? **Interrupts**
- CPU needs data but it takes a variable amount of time to get that information, while I work on something else.
    - Interrupt: Get a notification when data has arrived
- Polling is separate: Check periodically if the data has arrived

Interrupts are a way to improve processor utilization (as opposed to polling)
- When an interrupt fires, the CPU might ignore it but usually, we need to handle it.
    - When the computer is in sleep mode, we might want to ignore the key interrupt.
- OS, it will store the state of the CPU and whatever the processor is running, handles the interrupt and restores the state.
    - If CPU is in the middle of something that can not be interrupted, interrupts will be disabled.
- Source of Interrupts: We can put polling into four categories, based on their origin
    - Program - When doing concurrency, this is the most common one.
    - Timer - If we want to blink an led at a certain rate, timer will go again
    - Input/Output - Moving a mouse, keyboard input etc.
    - Hardware Failure - During a power outage, or battery low (not hardware failure but same idea), where the PC will safely shut itself off.

There can be multiple interrupts in a short period of time.
- In sequential handling, we finish Interrupt Handler X, and then go to Interrupt Handler Y.
    - The best way to think about this is two questions asking a teacher
- In nested handling, we go to Interrupt Handler X and then go to Interrupt Handler Y, finish it, finish X and go back
    - Makes sense if Y is higher priority, think of a teacher answering a student’s question (Interrupt Handler X) and a fire alarm starts (Interrupt Handler Y starts with obviously higher priority) In general, priorities are assigned a priority level. If priority level is higher, it will interrupt anything lower than it.

The OS must store the program state when an interrupt occurs (state being the values of registers). Push them onto the stack and when the interrupt is finished, pop them off the stack, and continue execution.

**Context Switching:** process of saving the state of one program and restoring the state of another, allowing the CPU to efficiently manage multiple tasks. **Trap**: software-generated interrupt. Generated by an error (invalid instruction) or user program request
