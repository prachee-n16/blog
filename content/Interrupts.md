Interrupts are a way to improve processor utilization (as opposed to polling)
- When an interrupt fires, the CPU might ignore it but usually, we need to handle it.
	- When the computer is in sleep mode, we might want to ignore the key interrupt.
- OS, it will store the state of the CPU and whatever the processor is running, handles the interrupt and restores the state.
	- If CPU is in the middle of something that can not be interrupted, interrupts will be disabled. 

- Source of Interrupts: We can put polling into four categories, based on their origin
	- Program - When doing concurrency, this is the most common one.
	- Timer - If we want to blink an led at a certain rate, timer will go again
	- Input/Output - Moving a mouse, keyboard input etc.
	- Hardware Failure - During a power outage, or battery low (not hardware failure but same idea), where the PC will safely shut itself off.

There can be multiple interrupts in a short period of time. 
- In sequential handling, we finish Interrupt Handler X, and then go to Interrupt Handler Y.
	- The best way to think about this is two questions asking a teacher
- In nested handling, we go to Interrupt Handler X and then go to Interrupt Handler Y, finish it, finish X and go back
	- Makes sense if Y is higher priority, think of a teacher answering a student's question (Interrupt Handler X) and a fire alarm starts (Interrupt Handler Y starts with obviously higher priority)
In general, priorities are assigned a priority level. If priority level is higher, it will interrupt anything lower than it.

The OS must store the program state when an interrupt occurs (state being the values of registers). Push them onto the stack and when the interrupt is finished, pop them off the stack, and continue execution.

**Context Switching:** process of saving the state of one program and restoring the state of another, allowing the CPU to efficiently manage multiple tasks.
**Trap**: software-generated interrupt. Generated by an error (invalid instruction) or user program request