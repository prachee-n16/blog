Interrupts are a way to improve processor utilization (as opposed to polling)
- When an interrupt fires, the CPU might ignore it but usually, we need to handle it.
    - When the computer is in sleep mode, we might want to ignore the key interrupt.
- OS, it will store the state of the CPU and whatever the processor is running, handles the interrupt and restores the state.
    - If CPU is in the middle of something that can not be interrupted, interrupts will be disabled.
- Source of Interrupts: We can put polling into four categories, based on their origin
    - Program - When doing concurrency, this is the most common one.
    - Timer - If we want to blink an led at a certain rate, timer will go again
    - Input/Output - Moving a mouse, keyboard input etc.
    - Hardware Failure - During a power outage, or battery low (not hardware failure but same idea), where the PC will safely shut itself off.

There can be multiple interrupts in a short period of time.
- In sequential handling, we finish Interrupt Handler X, and then go to Interrupt Handler Y.
    - The best way to think about this is two questions asking a teacher
- In nested handling, we go to Interrupt Handler X and then go to Interrupt Handler Y, finish it, finish X and go back
    - Makes sense if Y is higher priority, think of a teacher answering a student’s question (Interrupt Handler X) and a fire alarm starts (Interrupt Handler Y starts with obviously higher priority) In general, priorities are assigned a priority level. If priority level is higher, it will interrupt anything lower than it.

The OS must store the program state when an interrupt occurs (state being the values of registers). Push them onto the stack and when the interrupt is finished, pop them off the stack, and continue execution.

**Context Switching:** process of saving the state of one program and restoring the state of another, allowing the CPU to efficiently manage multiple tasks. **Trap**: software-generated interrupt. Generated by an error (invalid instruction) or user program request

**Trap**: software-generated interrupt. Generated by an error (invalid instruction) or user program request
- dereferencing a null pointer.

When processing input:
```
%% Tight polling until data is ready %%
while (!IsDeviceReady()) {
	%% Periodic polling %%
	usleep(1000);
	%% Occasional polling %%
	backgroundTask();
}

%% Read the input data %%
ReadData();

%% Clear ready flag if not done by hardware %%
ClearReady();

%% Process input data %%
ProcessData();

%% Exit subroutine and return to caller %%
return;
```

When processing output:
- the conservative option is checking if device is ready and then outputting data.
- the optimistic option is outputting data and then, checking when device is ready (assume device is ready on first iteration, less latency)

**Polling Overhead**
- tight polling will introduce overhead since frequent checks consume CPU cycles/ bus cycles
- periodic and occasional polling will introduce less overhead as there's pauses between checks





**Interrupt Service Routine** - special function that executes when triggered by an interrupt request, also called interrupt handlers
